/*
 * Created by : Charbel SALHAB, Andrei MALICEK, Janin MICHEL-MATHIAS
 * Date : 24/02/2023
 * "program allowing you to create your own hotel with number of rooms and type of room and service offered.
 * The rooms can be reserved by customers according to the criteria of the hotel."
 */

#include <stdio.h>
#include <yaml.h>
#include <string.h>
#include "../queries.h"

/*
 * set of functions that correspond to each of the yaml commands/queries in the input file "queries.yaml".
 * each function takes a pointer to a specific input type, such as GetHotel, CreateHotel, UpdateHotel, etc. 
 * and returns a specific output type, such as GetHotelReturn, CreateHotelReturn, UpdateHotelReturn, etc.
 */

GetHotelReturn getHotel(GetHotel *Example){
    printf("Récupération de l'hotel \n");
}

CreateHotelReturn createHotel(CreateHotel *Example){
    printf("hotel créé.\n");
}

UpdateHotelReturn updateHotel(UpdateHotel *Example){
    printf("hotel mis a jour.\n");
}

DeleteHotelReturn deleteHotel(DeleteHotel *Example){
    printf("hotel supprimé.\n");
}

GetRoomReturn getRoom(GetRoom *Example){
    printf("Récupération de la chambre \n");
}

CreateRoomReturn createRoom(CreateRoom *Example){
    printf("Chambre créée.\n");
}

UpdateRoomReturn updateRoom(UpdateRoom *Example){
    printf("Chambre mise à jour.\n");
}

DeleteRoomReturn deleteRoom(DeleteRoom *Example){
    printf("Chambre supprimée.\n");
}

GetReservationReturn getReservation(GetReservation *Example){
    printf("Récupération de la reservation \n");
}

CreateReservationReturn createReservation(CreateReservation *Example){
    printf("Réservation créée.\n");
}

UpdateReservationReturn updateReservation(UpdateReservation *Example){
    printf("Réservation mise à jour.\n");
}

DeleteReservationReturn deleteReservation(DeleteReservation *Example){
    printf("Réservation supprimée.\n");
}

GetClientReturn getClient(GetClient *Example){
    printf("Récupération du client \n");
}

CreateClientReturn createClient(CreateClient *Example){
    printf("Client créé.\n");
}

UpdateClientReturn updateClient(UpdateClient *Example){
    printf("Client mis à jour.\n");
}

DeleteClientReturn deleteClient(DeleteClient *Example){
    printf("Client supprimé.\n");
}

GetEmployeeReturn getEmployee(GetEmployee *Example){
    printf("Récupération de l'employe \n");
}

CreateEmployeeReturn createEmployee(CreateEmployee *Example){
    printf("Employé créé.\n");
}

UpdateEmployeeReturn updateEmployee(UpdateEmployee *Example){
    printf("Employé mis à jour.\n");
}

DeleteEmployeeReturn deleteEmployee(DeleteEmployee *Example){
    printf("Employé supprimé.\n");
}

int main(int argc, char** argv) {

    //open "queries.yaml" file
    FILE *file = fopen("queries.yaml", "rb");

    //this structure will be used to initialize and manipulate the yaml parser
    yaml_parser_t parser;

    //this structure will be used to store information about each yaml event generated by the parser
    yaml_event_t event;

    int done = 0;
    char *command;

    GetHotel *ghotel;
    CreateHotel *chotel;
    UpdateHotel *uhotel;
    DeleteHotel *dhotel;

    GetRoom *groom;
    CreateRoom *croom;
    UpdateRoom *uroom;
    DeleteRoom *droom;

    GetClient *gclient;
    CreateClient *cclient;
    UpdateClient *uclient;
    DeleteClient *dclient;

    GetReservation *greservation;
    CreateReservation *creservation;
    UpdateReservation *ureservation;
    DeleteReservation *dreservation;

    GetEmployee *gemployee;
    CreateEmployee *cemployee;
    UpdateEmployee *uemployee;
    DeleteEmployee *demployee;

    //if the initialization of yaml parser fails, it will print an error message
    //and exit the program (it returns 1)
    if (!yaml_parser_initialize(&parser)) {
        fprintf(stderr, "Failed to initialize YAML parser\n");
        return 1;
    }

    //set the input file for the yaml parser, 
    //here -> the "queries.yaml" file
    yaml_parser_set_input_file(&parser, file);

    /*
     *  the while loop will run until the end of the yaml file "queries.yaml" is reached.
     *  parse the next event in the yaml stream. if parsing fails, an error message is printed.
     *  
     * the switch loop is used to check the type of the current event : 
     * 
     *      1- if the event is the start of a mapping, do nothing.
     *      2- if the event is a scalar aka a string, extract its value.
     *      3- use a series of if-else statements to determine which command was given.
     *      4- if the command is GetHotel, call the getHotel function with the appropriate arguments
     *      and etc.
     *      5- when the end of a yaml mapping is reached, which marks the end of a section of the yaml file, do nothing.
     *      6- when the end of the yaml file is reached, set the done variable to '1', indicating that the program has finished processing the 
     *      "queries.yaml" file, and then breaks out of the case YAML_STREAM_END_EVENT.
     */

    while (!done) {
        
        if (!yaml_parser_parse(&parser, &event)) {
            fprintf(stderr, "Failed to parse YAML event\n");
            return 1;
        }

        switch (event.type) {
            
            case YAML_MAPPING_START_EVENT:
                break;
            
            case YAML_SCALAR_EVENT:
                
                command = event.data.scalar.value;
                // printf("%s\n", event.data.scalar.value);
                if (strcmp(command, "GetHotel") == 0) {
                    getHotel(ghotel);
                } else if (strcmp(command, "CreateHotel") == 0){
                    createHotel(chotel);
                } else if (strcmp(command, "UpdateHotel") == 0){
                    updateHotel(uhotel);
                }else if (strcmp(command, "DeleteHotel") == 0){
                    deleteHotel(dhotel);
                }else if (strcmp(command, "GetRoom") == 0){
                    getRoom(groom);
                }else if (strcmp(command, "CreateRoom") == 0){
                    createRoom(croom);
                }else if (strcmp(command, "UpdateRoom") == 0){
                    updateRoom(uroom);
                }else if (strcmp(command, "DeleteRoom") == 0){
                    deleteRoom(droom);
                }else if (strcmp(command, "GetReservation") == 0){
                    getReservation(greservation);
                }else if (strcmp(command, "CreateReservation") == 0){
                    createReservation(creservation);
                }else if (strcmp(command, "UpdateReservation") == 0){
                    updateReservation(ureservation);
                }else if (strcmp(command, "DeleteReservation") == 0){
                    deleteReservation(dreservation);
                }else if (strcmp(command, "GetClient") == 0){
                    getClient(gclient);
                }else if (strcmp(command, "CreateClient") == 0){
                    createClient(cclient);
                }else if (strcmp(command, "UpdateClient") == 0){
                    updateClient(uclient);
                }else if (strcmp(command, "DeleteClient") == 0){
                    deleteClient(dclient);
                }else if (strcmp(command, "GetEmployee") == 0){
                    getEmployee(gemployee);
                }else if (strcmp(command, "CreateEmployee") == 0){
                    createEmployee(cemployee);
                }else if (strcmp(command, "UpdateEmployee") == 0){
                    updateEmployee(uemployee);
                }else if (strcmp(command, "DeleteEmployee") == 0){
                    deleteEmployee(demployee);
                }
                break;
            
            case YAML_MAPPING_END_EVENT:
                break;
            
            case YAML_STREAM_END_EVENT:
                done = 1;
                break;
            
            default:
                break;

        }

        //delete the yaml event object
        yaml_event_delete(&event);
    }

    //delete the yaml parser object and free the memory allocated for it
    //after the parsing is complete and all data is extracted from the yaml file
    yaml_parser_delete(&parser);

    //close the "queries.yaml" file
    fclose(file);

    return 0;
}
